+++
title = 'Explorando Distros: Minha Jornada para Dominar o Linux'
date = 2024-11-24T18:28:48-03:00
draft = false
+++

Aqui est√° como eu aprendi, basicamente, como as distribui√ß√µes Linux s√£o feitas.

# O In√≠cio

Quando eu tinha 6 anos, ouvi minha m√£e dizer que a luz do forno dela n√£o estava acendendo, ent√£o fui l√° para descobrir o porqu√™.
Encontrei um conector que n√£o estava plugado, ent√£o o conectei e voil√†, consertei.  

Essa foi minha primeira experi√™ncia resolvendo problemas e me sentindo recompensado por isso.  
Desde ent√£o, fiquei fascinado por tecnologia.

Quando minha tia me dava o celular dela (na √©poca, um celular "de bot√£o"), eu explorava as configura√ß√µes, os recursos, os jogos, tudo que ele poderia oferecer, apenas para satisfazer minha curiosidade.

## Meu Primeiro PC

Aos 12 anos, meu av√¥ me deu o computador dele porque estava comprando um novo.  
Aquele computador era MUITO lento, mas isso foi √≥timo para me motivar a buscar por t√©cnicas de otimiza√ß√£o.  

Naquela √©poca, tudo o que eu queria era jogar Minecraft com meus amigos, ent√£o comecei a buscar maneiras de fazer isso.  
O Windows 7 era pesado demais, ent√£o tentei ajustar as configura√ß√µes para desempenho, mas isso n√£o funcionou.  
Instalei o Windows XP s√≥ para rodar Minecraft no m√≠nimo poss√≠vel, usando todos os mods que encontrei para melhorar o desempenho e, no final, rodava a 10-15 fps.  

Como isso n√£o era jog√°vel enquanto rodava qualquer outro programa, fui buscar mais otimiza√ß√µes.  
Comprar hardware novo n√£o era uma op√ß√£o, j√° que minha fam√≠lia nunca permitiria comprar algo apenas para entretenimento; s√≥ compr√°vamos se fosse √∫til para economizar tempo ou ganhar dinheiro.  

Ent√£o, testei v√°rios "programas" que prometiam melhorar o desempenho, mas todos n√≥s sabemos que isso √© uma grande mentira. üí©  
Como qualquer um poderia imaginar, instalei v√°rios v√≠rus. Um que se destacou foi um trojan feito com o [njRAT](https://en.wikipedia.org/wiki/NjRAT).  

Como descobri sobre isso? Bem... √â uma hist√≥ria bem interessante:

Estava pesquisando algo no meu celular quando vi o cursor se mover sozinho. Achei engra√ßado e fiquei observando.  
O computador abriu o navegador e come√ßou a procurar minhas contas em redes sociais. Assim que vi isso, dei um "Alt+F4" no navegador e abri o bloco de notas, escrevendo: "O que voc√™ quer?"  

Eu consegui mover o cursor porque minha conex√£o de internet era bem ruim, ent√£o o trojan n√£o conseguia bloquear os eventos a tempo.  

A partir da√≠, o "hacker" e eu come√ßamos a conversar sobre coisas de hacking, como trojans, keyloggers, clubes de hackers, etc.  
No final, apenas encerrei o processo do v√≠rus pelo Gerenciador de Tarefas e o desinstalei manualmente.  

Isso me inspirou a entender como esses v√≠rus funcionavam, mas, na √©poca, achei muito complicado aprender, ent√£o desisti.

Depois de procurar em todo canto da internet, encontrei algumas pessoas falando sobre Linux e como ele era √≥timo para computadores antigos e hacking.  
Ent√£o, sem d√∫vidas, mergulhei de cabe√ßa.

# A Primeira Experi√™ncia com o Ubuntu

Como praticamente todo mundo, minha primeira distro foi o Ubuntu.  
Baixei o ISO do [site](https://ubuntu.com/download/desktop), o [Rufus](https://rufus.ie/en/), peguei um pendrive e o sonho de um computador r√°pido.  
Seguindo tutoriais no YouTube, consegui instal√°-lo.

Na mesma √©poca, comecei a me interessar por programa√ß√£o, ent√£o queria rodar a pilha LAMP (Linux, Apache2, MySQL e PHP).  
Por sorte, encontrei um meta-pacote no Ubuntu que instala toda a pilha e a configura!  
Mas as coisas sempre d√£o errado quando chega MINHA vez de fazer funcionar. üò¢  

A configura√ß√£o deu errado. Tudo o que tentei para consertar n√£o funcionou. Pensei: "Vou apenas desinstalar e instalar novamente para ver o que acontece".  
Foi a√≠ que tudo come√ßou a dar errado: o gerenciador de pacotes APT, de alguma forma, tinha um bug que desinstalou TODO O SISTEMA.

Desisti do Ubuntu e fui procurar uma alternativa.

# Linux Mint

Instalei o [Linux Mint](https://www.linuxmint.com/download.php) depois de um tempo, do mesmo jeito que fiz com o Ubuntu.  
Dessa vez, ao instalar o LAMP, fiz tudo manualmente (porque aprendi a li√ß√£o com o Ubuntu üòÜ), programa por programa, e funcionou! Legal! üòÉ  

Abri o Minecraft: melhor desempenho do que no Windows XP, mas ainda lento demais para jogar bem.  
Ent√£o comecei a experimentar outras distros.

# PopOS

Instalei o [PopOS](https://pop.system76.com/). Que experi√™ncia incr√≠vel!  
Desativei o compositor e algumas anima√ß√µes (como se eu soubesse o que estava fazendo. üòÜ).

O [Pop Shell](https://github.com/pop-os/shell) era INCR√çVEL! Podia abrir janelas e posicion√°-las automaticamente onde queria na tela.  

Naquela √©poca, ganhei um computador de presente por terminar o ensino fundamental. Mesmo sendo um computador mais potente, ainda procurava MAIS desempenho!  
Agora, o objetivo era alcan√ßar pelo menos 300+ fps no [CSGO](https://en.wikipedia.org/wiki/Counter-Strike:_Global_Offensive).

Ent√£o, entrei no hype:

# Arch Linux

[Arch Linux](https://archlinux.org/) √© uma distribui√ß√£o que oferece apenas as ferramentas necess√°rias para voc√™ construir seu pr√≥prio sistema altamente customizado, ou seja, nada al√©m de um sistema base, um gerenciador de pacotes e um shell. Voc√™ baixa os programas conforme a necessidade. A instala√ß√£o tamb√©m √© totalmente manual, o que significa que muitas coisas podem dar errado, mas isso tamb√©m proporciona muita flexibilidade.

Sim, eu [instalei](https://wiki.archlinux.org/title/Installation_guide) o Arch Linux mais de 12 vezes. ü§£

Minha mente n√£o conseguia entender como as coisas funcionavam nesse sistema. Tudo parecia um grande "gambiarra".  
Mais tarde, descobri que TODOS os sistemas de software s√£o assim. Alguns apenas escondem melhor do que outros. ü•≤

Aqui est√° uma vis√£o geral r√°pida de como o Arch Linux funciona (e a maioria das outras distros Linux em PCs tamb√©m):

1. A placa-m√£e inicia o [BIOS](https://en.wikipedia.org/wiki/BIOS), realiza o [POST](https://en.wikipedia.org/wiki/Power-on_self-test) e procura por um disco r√≠gido para inicializar.

2. Existem dois tipos de esquemas de particionamento de disco, ou seja, formas de dividir discos em m√∫ltiplos discos virtuais. Isso geralmente permite maior flexibilidade no armazenamento, como em [RAID](https://en.wikipedia.org/wiki/RAID).  
Esses tipos s√£o [MBR](https://en.wikipedia.org/wiki/Master_boot_record) e [GPT](https://en.wikipedia.org/wiki/GUID_Partition_Table).  
De forma geral, se o seu computador for recente, use GPT. Caso contr√°rio, MBR.

3. Existem dois tipos de sistemas de boot: [BIOS](https://en.wikipedia.org/wiki/BIOS_boot_partition) e [UEFI](https://en.wikipedia.org/wiki/UEFI).

    1. Se voc√™ estiver usando BIOS, o firmware carrega os primeiros 512 bytes do disco na mem√≥ria e coloca o contador de programa nesses bytes. Isso significa que o que estiver nos primeiros 512 bytes do disco deve carregar as outras partes do bootloader na mem√≥ria.

    2. Se voc√™ estiver usando UEFI, o firmware procura por uma parti√ß√£o com o flag "esp" formatada como [FAT-32](https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32) para carregar o bootloader.  
De forma geral, se o seu computador for recente, use UEFI. Caso contr√°rio, BIOS.

4. Existem MUITOS bootloaders capazes de inicializar o Linux, ou seja, configurar a CPU e a mem√≥ria para iniciar o kernel Linux, o programa que controla o hardware do computador. Alguns dos mais populares s√£o [GRUB2](https://en.wikipedia.org/wiki/GNU_GRUB), [Systemd-boot](https://en.wikipedia.org/wiki/Systemd-boot) e [Limine](https://limine-bootloader.org/).  
Cada kernel espera um ambiente para inicializar, e para isso, foram criados protocolos de boot. O bootloader cuida de implementar esses protocolos para os kernels serem inicializados corretamente, al√©m de permitir m√∫ltiplos sistemas operacionais no mesmo computador, ou seja, [Multi-boot](https://en.wikipedia.org/wiki/Multi-booting) (mais conhecido como Dual-Boot).

5. O kernel Linux √© respons√°vel por implementar formas seguras para que programas de usu√°rio acessem componentes de hardware. Geralmente isso significa criar [Syscalls](https://en.wikipedia.org/wiki/System_call) para permitir que programas de usu√°rio se comuniquem com o kernel, solicitando acesso a disco, mem√≥ria, prioridade, recursos, etc.  
Para simplificar, o kernel se inicializa e entrega o controle para um programa de usu√°rio. Geralmente, esse primeiro programa √© chamado de [Init](https://en.wikipedia.org/wiki/Init) system. Existem muitos init systems, mas os mais comuns s√£o, respectivamente, [Systemd](https://en.wikipedia.org/wiki/Systemd), [OpenRC](https://en.wikipedia.org/wiki/OpenRC) e [Runit](https://en.wikipedia.org/wiki/Runit).  
O init system √© respons√°vel por gerenciar quais programas ser√£o executados em segundo plano ([Daemons](https://en.wikipedia.org/wiki/Daemon_(computing))), assim como aqueles que ser√£o executados na inicializa√ß√£o, desligamento, suspens√£o, hiberna√ß√£o, periodicamente, etc.

6. O init system ent√£o coloca o usu√°rio em um [TTY](https://en.wikipedia.org/wiki/Tty_(Unix)), executando um [Shell](https://en.wikipedia.org/wiki/Unix_shell) ou uma interface gr√°fica como [X](https://en.wikipedia.org/wiki/X_Window_System) ou [Wayland](https://en.wikipedia.org/wiki/Wayland_(protocol)).

Algumas coisas que voc√™ pode precisar saber no sistema Linux:
- apt, pacman, yum, dnf, portage, xbps... - Gerenciadores de pacotes: instalam programas e servi√ßos para sua distro Linux.
- fdisk, parted, gparted, ... - Gerenciadores de disco: formatam, particionam e gerenciam discos.
- ext4, fat32, btrfs, zfs, ... - Sistemas de arquivos: sistemas para gerenciar arquivos de forma eficiente.
- swap - Arquivo ou parti√ß√£o especial reservada para o Linux usar o disco como backup para a mem√≥ria RAM.
- /etc/fstab - Arquivo que descreve quais parti√ß√µes ser√£o montadas na inicializa√ß√£o.
- /etc/hostname - Arquivo que nomeia seu computador na rede local.

Existem muitas coisas para detalhar, ent√£o voc√™ poderia usar um instalador do Arch Linux como [ArchFI](https://github.com/MatMoul/archfi) e pesquisar o que cada programa faz, al√©m de ler a [lista de aplica√ß√µes](https://wiki.archlinux.org/title/List_of_applications) na Arch Wiki. Voc√™ pode encontrar aplicativos muito √∫teis l√°!

Depois de toda essa informa√ß√£o que aprendi, ainda n√£o fiquei satisfeito at√© chegar ao ponto em que n√£o h√° mais nada que eu possa otimizar no meu sistema. Ent√£o fui para o Gentoo.
# Gentoo

[Gentoo](https://www.gentoo.org/) √© uma distro onde voc√™ recebe um sistema "base" e todo o resto √© compilado a partir do c√≥digo-fonte. Isso significa que o gerenciador de pacotes "portage" baixa o c√≥digo-fonte do software escrito em [Linguagens de Programa√ß√£o](https://en.wikipedia.org/wiki/Programming_language) e usa [Compiladores](https://en.wikipedia.org/wiki/Compiler) para traduzir o c√≥digo para um formato [Execut√°vel](https://en.wikipedia.org/wiki/Executable), ou seja, uma linguagem que o computador possa entender.  
Tamb√©m podemos especificar quais otimiza√ß√µes os compiladores podem realizar com base no hardware em que o programa ser√° executado, otimizando ao m√°ximo sem alterar o c√≥digo-fonte.

Usei o Gentoo por um pouco mais de 2 meses. A performance era realmente impressionante!  
Aprendi muito sobre bibliotecas din√¢micas, flags de compila√ß√£o, extens√µes de CPU, m√≥dulos do kernel, patches, etc.  
Recomendo fortemente para todos que querem ser desenvolvedores ou engenheiros de software experimentarem, pois for√ßa voc√™ a aprender como os programas do sistema s√£o constru√≠dos.

Eventualmente, percebi que estava gastando mais tempo ajustando flags de compila√ß√£o e atualizando o sistema do que gostaria. Ent√£o, chegou a hora de voltar para algo um pouco mais "humano".

Voltei para o Arch Linux e fiquei l√° por um bom tempo, at√© ouvir falar sobre o NixOS no ano passado.

# NixOS

[NixOS](https://nixos.org/) √© uma distro bem diferente das outras, especialmente por causa do gerenciador de pacotes [Nix](https://en.wikipedia.org/wiki/Nix_(package_manager)).

Algumas desvantagens s√£o:  
1. O NixOS tem pouca ou nenhuma documenta√ß√£o se comparado ao Arch Linux, ent√£o voc√™ precisa aprender muitas coisas apenas lendo o c√≥digo de outras pessoas.  
2. Muitos programas esperam que as distros sigam o padr√£o [FHS](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard), ent√£o os pacotes do NixOS precisam de muitos patches e ajustes para funcionar corretamente.

Basicamente, ele funciona com arquivos ".nix" escritos em uma linguagem de programa√ß√£o [declarativa](https://en.wikipedia.org/wiki/Declarative_programming) e [funcional](https://en.wikipedia.org/wiki/Functional_programming) chamada Nix. Esses arquivos descrevem como o estado do sistema deve ser mantido, gerando sempre o mesmo resultado a cada compila√ß√£o e aplicando todas as mudan√ßas necess√°rias para alcan√ßar aquele estado.  
Isso geralmente significa que voc√™ declara como quer que seu sistema seja e n√£o pode alter√°-lo acidentalmente executando um comando no terminal, pois as mudan√ßas precisam ser feitas no arquivo nix e aplicadas.

Ao mesmo tempo, voc√™ tamb√©m pode executar programas sem instal√°-los usando `nix run`, criar shells personalizados com programas espec√≠ficos usando `nix shell` ou criar ambientes de desenvolvimento isolados com `nix develop`, contendo apenas os programas necess√°rios para o projeto, sem instal√°-los no sistema principal.

Cada novo projeto pode ser um grande desafio para fazer funcionar, mas, uma vez configurado, voc√™ nunca mais pensar√° naquela famosa frase que todo desenvolvedor j√° ouviu:  

"Funciona no meu computador".  

Porque se um projeto funciona em um sistema, ele definitivamente funcionar√° em outros computadores.  
Os projetos em Nix s√£o "puros" por padr√£o, o que significa que ter√£o todas as configura√ß√µes necess√°rias para rodar exatamente como no computador do desenvolvedor.

# O fim?

Ainda uso o NixOS como meu sistema principal no dia a dia.  
Se quiser ver minha configura√ß√£o do NixOS, voc√™ pode acess√°-la [aqui](https://github.com/haru02w/dotfiles).

Como Arist√≥teles escreveu uma vez: "Quanto mais voc√™ sabe, mais percebe que n√£o sabe."  
Acho que, com tudo isso, adquiri experi√™ncia suficiente sobre como o Linux funciona, mas tamb√©m identifiquei v√°rias coisas que posso melhorar, como:  
- Algoritmos usados em sistemas operacionais  
- Sistemas internos do kernel, como redes, escalonamento de tarefas, drivers de v√≠deo, etc.  
- Computa√ß√£o paralela  
- Solu√ß√µes de auto-escalonamento  
- Terraform, Ansible, Kubernetes, Docker, OpenStack, AWS, etc.  

Isso √© tudo para este post. Obrigado pela aten√ß√£o e at√© a pr√≥xima! Tchau üëã
